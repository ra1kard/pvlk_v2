# Принципы SOLID

## Описание

Принципы SOLID — это набор пяти ключевых принципов, которые помогают в проектировании гибких, поддерживаемых и легко
расширяемых систем. Давайте разберём каждый из этих принципов с примерами на Java и объяснением, почему важно их
применять.

**_S_** - _Single Responsibility Principle (SRP)_ — Принцип единственной ответственности

**_O_** - _Open/Closed Principle (OCP)_ — Принцип открытости/закрытости

**_L_** - _Liskov Substitution Principle (LSP)_ — Принцип подстановки Барбары Лисков

**_I_** - _Interface Segregation Principle (ISP)_ — Принцип разделения интерфейса

**_D_** - _Dependency Inversion Principle (DIP)_ — Принцип инверсии зависимостей

## Принципы SOLID

### Принцип единой ответственности (SRP)

Принцип единой ответственности говорит о том, что каждый класс должен иметь только одну причину для изменения, то есть
быть ответственным только за одно задание.

Рассмотрим пример нарушения принципа единой ответственности. Дан класс генерации отчёта, который генерирует отчёт,
а также занимается его отправкой и печатью. Такой подход увеличит количество причин для изменения этого класса.

```java
class ReportGenerator {
    public void generateReport() {
        // Генерация отчета
    }

    public void printReport() {
        // Печать отчета
    }

    public void sendReportByEmail() {
        // Отправка отчета по email
    }
}
```

Мало того, что отправка отчёта и его печать никак не коррелируются с названием класса `ReportGenerator`, так ещё и
изменение любой из этих функций повлечёт за собой полное тестирование этого класса. В соответствии с принципом единой
ответственности класс должен иметь только одну причину для изменения, а в примере выше этих причин целых три.

Правильный вариант:

```java
class ReportGenerator {
    public void generateReport() {
        // Генерация отчета
    }
}

class ReportPrinter {
    public void printReport() {
        // Печать отчета
    }
}

class EmailSender {
    public void sendReportByEmail() {
        // Отправка отчета по email
    }
}
```

Такой код будет легче поддерживать и модифицировать. Если нужно будет изменить логику отправки по email или логику
печати отчёта -
это не затронет логику формирования отчёта.

### Принцип открытости/закрытости (OCP)

Принцип открытости/закрытости говорит о том, что программные сущности должны быть открыты для расширения, но закрыты для
модификации.

Рассмотрим пример нарушения принципа открытости/закрытости. Есть метод, который выполняет расчёт скидки, в зависимости
от её типа:

```java
class DiscountCalculator {
    public double calculateDiscount(String type, double amount) {
        if (type.equals("STUDENT")) {
            return amount * 0.1;
        } else if (type.equals("SENIOR")) {
            return amount * 0.15;
        }
        return 0;
    }
}
```

Тут сразу появляется проблема: если появится новый тип скидки, то придётся модифицировать метод. Любая модификация
метода - это возможность возникновения ошибок в тех местах, где раньше всё работало хорошо, что повлечёт за собой
дополнительные затраты на тестирование.

Преобразуем расчёт скидки в соответствии с принципом открытости/закрытости:

```java
interface DiscountStrategy {
    double applyDiscount(double amount);
}

class StudentDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.1;
    }
}

class SeniorDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.15;
    }
}

class DiscountCalculator {
    public double calculateDiscount(DiscountStrategy strategy, double amount) {
        return strategy.applyDiscount(amount);
    }
}
```

В итоге, был получен код, который легко поддаётся масштабированию. Новые типы скидок можно добавлять без изменения
существующего кода.

### Принцип подстановки Барбары Лисков (LSP)

Принцип подстановки Барбары Лисков гласит, что объекты должны быть заменяемыми на экземпляры их подклассов без нарушения
программы.

Принцип подстановки Лисков заключается в том, что поведение наследуемого класса (подкласса) должно быть согласовано с
поведением базового класса. Если код работает с объектом родительского класса, то он должен также работать и с объектом
любого подкласса этого класса.

Если нарушать LSP, это приводит к таким проблемам, как неожиданное поведение программы, усложнение тестирования и
сопровождения кода, и затрудняет дальнейшую разработку.

Пример на простом уровне: если у вас есть класс `Кот` и вы создаете подкласс `Лев`, то с точки зрения внешнего
поведения `Лев`
должен вести себя как `Кот`. Если в коде ожидается использование объекта `Кот`, мы должны иметь возможность без проблем
использовать объект `Лев`.

Рассмотрим пример нарушения принципа подстановки Барбары Лисков. Есть класс `Bird`, от которой наследуется
класс `Penguin`. Проблема заключается в том, что в классе `Bird` есть метод `fly`, а пингвины летать не умеют.

```java
class Bird {
    public void fly() {
        System.out.println("Птица летит");
    }
}
```

```java
class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Пингвин не умеет летать");
    }
}
```

С точки зрения принципа подстановки Лисков, здесь есть проблема. Хотя пингвины являются птицами по логике наследования,
они не могут летать, а это нарушает ожидания от класса `Bird`. В коде, где ожидается возможность полёта, вызов
метода `fly`
у объекта `Penguin` приведёт к ошибке:

```java
public class Main {
    public static void main(String[] args) {
        Bird bird = new Penguin();  // Замена Bird на Penguin
        bird.fly();  // Программа вызовет исключение
    }
}
```

Один из способов решения этой проблемы — изменить структуру иерархии классов, чтобы базовый класс не навязывал всем
подклассам функциональность, которая им не свойственна. Можно выделить интерфейсы для различных видов поведения.

Исправленный вариант будет выглядеть следующим образом:

```java
interface Flyable {
    void fly();
}

class Bird {
    // Общие свойства для всех птиц
}

class FlyingBird extends Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Птица летит");
    }
}

class Penguin extends Bird {
    // Пингвин не может летать, поэтому не реализует интерфейс Flyable
}

class Eagle extends FlyingBird {
}
```

Теперь классы `FlyingBird` и его подклассы, например, `Eagle`, будут иметь метод `fly`, тогда как `Penguin` не будет его
иметь.
Это устраняет нарушение _LSP_.

#### Требования к соблюдению принципа LSP

Для того чтобы класс соответствовал LSP, его подклассы должны соответствовать следующим правилам:

1. Контракт предка должен сохраняться: Подкласс не должен изменять поведение базового класса таким образом, чтобы
   вызвать
   нарушение в работе программы. Это относится как к методам, так и к инвариантам (ограничениям, которые класс налагает
   на
   своё состояние).

2. Постусловия не должны ослабляться: Подкласс не должен делать менее строгими условия после выполнения метода.
   Например,
   если метод базового класса гарантирует определённый результат, то подкласс не может нарушать эти гарантии.

3. Предусловия не должны усиливаться: Подкласс не должен требовать более строгих условий для выполнения своих методов.
   Если
   метод базового класса ожидает, что ему передают определённые параметры, подкласс не может требовать более узких
   диапазонов значений.

4. Сохранение инвариантов: Подклассы не должны изменять общие ограничения, которые накладываются на состояние объекта.
   Например, если базовый класс накладывает ограничение на диапазон значений какого-то свойства, подкласс не должен
   нарушать это правило.

### Принцип разделения интерфейса (ISP)

Принцип разделения интерфейса гласит, что клиенты не должны зависеть от методов, которые они не используют.

То есть интерфейсы должны быть разделены на более мелкие, узко специализированные, чтобы клиенты (классы, использующие
интерфейсы) не были вынуждены реализовывать ненужные им методы. Это помогает избежать избыточной связи между
компонентами системы.

Принцип разделения интерфейса решает проблему "жирных" интерфейсов, которые содержат множество методов, не связанных
друг с другом. Если классы вынуждены реализовывать методы, которые им не нужны, это приводит к:

* Усложнению реализации классов.
* Увеличению количества ненужных зависимостей.
* Лишней сложности при поддержке и тестировании.
* Большей вероятности появления ошибок.

Рассмотрим пример нарушения принципа разделения интерфейса. Представим ситуацию, где у нас есть интерфейс `Worker`,
описывающий рабочие функции:

```java
interface Worker {
    void work();

    void eat();
}
```

Также, есть два типа рабочих: робот и человек.

```java
class HumanWorker implements Worker {
    @Override
    public void work() {
        System.out.println("Человек работает");
    }

    @Override
    public void eat() {
        System.out.println("Человек ест");
    }
}
```

```java
class RobotWorker implements Worker {
    @Override
    public void work() {
        System.out.println("Робот работает");
    }

    @Override
    public void eat() {
        // Роботы не едят, но они обязаны реализовать этот метод
    }
}
```

Роботы не должны реализовывать метод eat, так как им это не нужно. Однако они вынуждены это делать, потому что интерфейс
`Worker` включает этот метод. Это приводит к тому, что интерфейс становится слишком широким, и не все клиенты могут его
корректно использовать.

Принцип разделения интерфейсов подразумевает, что нужно разделить интерфейс на более узкие, специализированные
интерфейсы, которые будут предоставлять только ту функциональность, которая действительно необходима конкретным
клиентам.

Исправленный вариант будет выглядеть следующим образом:

```java
interface Workable {
    void work();
}
```

```java
interface Eatable {
    void eat();
}
```

```java
class HumanWorker implements Workable, Eatable {
    @Override
    public void work() {
        System.out.println("Человек работает");
    }

    @Override
    public void eat() {
        System.out.println("Человек ест");
    }
}
```

```java
class RobotWorker implements Workable {
    @Override
    public void work() {
        System.out.println("Робот работает");
    }
}
```

Теперь `RobotWorker` реализует только интерфейс `Workable` и не вынужден реализовывать ненужный метод `eat`, поскольку
он для
него не актуален. Это следование принципу _ISP_.

Применение принципа разделения интерфейсов имеет смысл, когда:

1. Интерфейс растёт и становится слишком большим: Если вы замечаете, что интерфейс начинает содержать множество методов,
   не связанных друг с другом, возможно, пришло время разделить его на более узкие интерфейсы.
2. Разные классы используют разные подмножества методов интерфейса: Когда несколько классов, реализующих один интерфейс,
   вынуждены реализовывать методы, которые они не используют, это явный признак нарушения ISP.
3. Необходимость частого изменения интерфейса: Если вы замечаете, что интерфейс постоянно изменяется для различных
   классов, это может указывать на его чрезмерную универсальность. Подобные изменения увеличивают риск внесения ошибок и
   усложняют поддержку.

### Принцип инверсии зависимостей (DIP)

Принцип инверсии зависимостей гласит: Модули верхнего уровня не должны зависеть от модулей нижнего уровня.
Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Проще говоря, классы верхнего уровня, которые определяют логику программы, не должны напрямую зависеть от классов
нижнего уровня (реализаций). Вместо этого они должны зависеть от абстракций (например, интерфейсов или абстрактных
классов).

Целью инверсии зависимостей является разрыв прямых зависимостей между высокоуровневыми и низкоуровневыми модулями. Это
важно по следующим причинам:

* Изменения в деталях реализации не должны затрагивать основные компоненты системы.
* Абстракции делают код более гибким и позволяют легко заменять детали реализации.
* Способствует более лёгкому тестированию и сопровождению кода.

Рассмотрим пример нарушения принципа инверсии зависимостей. Есть класс `LightSwitch` управляющий лампой:

```java
class LightBulb {
    public void turnOn() {
        System.out.println("Лампа включена");
    }

    public void turnOff() {
        System.out.println("Лампа выключена");
    }
}
```

```java
class LightSwitch {
    private LightBulb lightBulb;

    public LightSwitch() {
        this.lightBulb = new LightBulb();
    }

    public void turnOn() {
        lightBulb.turnOn();
    }

    public void turnOff() {
        lightBulb.turnOff();
    }
}
```

В этом примере класс `LightSwitch` зависит от конкретного класса `LightBulb`. Это нарушает _DIP_, поскольку класс
высокого
уровня (`LightSwitch`) зависит от деталей реализации (`LightBulb`). Если нам понадобится изменить тип лампы, например,
на
светодиодную лампу (_LED_), то придётся модифицировать код `LightSwitch`.

Исправленный вариант будет выглядеть следующим образом:

```java
interface Switchable {
    void turnOn();

    void turnOff();
}
```

```java
class LightBulb implements Switchable {
    @Override
    public void turnOn() {
        System.out.println("Лампа включена");
    }

    @Override
    public void turnOff() {
        System.out.println("Лампа выключена");
    }
}
```

```java
class LedBulb implements Switchable {
    @Override
    public void turnOn() {
        System.out.println("LED лампа включена");
    }

    @Override
    public void turnOff() {
        System.out.println("LED лампа выключена");
    }
}
```

```java
class LightSwitch {
    private Switchable device;

    public LightSwitch(Switchable device) {
        this.device = device;
    }

    public void turnOn() {
        device.turnOn();
    }

    public void turnOff() {
        device.turnOff();
    }
}
```

Теперь класс `LightSwitch` зависит не от конкретного класса лампы, а от абстракции `Switchable`. Это позволяет нам легко
заменять конкретные реализации лампочек, не меняя код `LightSwitch`. Мы можем передавать как `LightBulb`, так
и `LedBulb` в
качестве зависимости:

```java
public class Main {
    public static void main(String[] args) {
        Switchable bulb = new LightBulb();
        LightSwitch lightSwitch = new LightSwitch(bulb);
        lightSwitch.turnOn();
        lightSwitch.turnOff();

        Switchable ledBulb = new LedBulb();
        lightSwitch = new LightSwitch(ledBulb);
        lightSwitch.turnOn();
        lightSwitch.turnOff();
    }
}
```

Проблемы при нарушении принципа инверсии зависимостей:

1. Трудности с модификацией и расширением: Если модуль высокого уровня напрямую зависит от реализации, то при изменении
этой реализации потребуется изменение и модуля высокого уровня.
2. Увеличение связности: Наличие жёсткой зависимости между модулями делает код менее гибким, что затрудняет его поддержку и
тестирование. 
3. Сложность тестирования: При отсутствии абстракций становится сложно тестировать модули по отдельности, так как
тестируемый код зависит от конкретных классов.