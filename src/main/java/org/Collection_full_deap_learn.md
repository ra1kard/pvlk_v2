# Углубленное изучение коллекций

### Сначала пробежимся по всем коллекциям ->




# Какие бывают коллекции в Java? 

https://sky.pro/wiki/python/ponimaem-funktsiyu-enumerate-v-python-na-primere-koda/

Коллекции и списки позволяют хранить и управлять группами объектов, что делает код более организованным и эффективным.

Коллекции в Java включают в себя различные типы структур данных, 
такие как СПИСКИ, МНОЖЕСТВА и КАРТЫ. 
Каждый из этих типов имеет свои особенности и предназначен для решения различных задач:

- **List (списки)**
- **Set (множества)**
- **Map (карты)**


## Основные интерфейсы коллекций: List, Set, и Map

1. List (список). 

    Упорядоченная коллекция элементов, допускающая дубликаты. Основные реализации: ArrayList и LinkedList.

- могут содержить ДУБЛИКАТЫ
- позволяет хранить элементы в определенном ПОРЯДКЕ

___ 

2. Set (множество). 

    Коллекция уникальных элементов, не допускающая дублирование данных. Основные реализации: HashSet и TreeSet. 

- НЕ допускают ДУПЛИКАТОВ
- НЕ гарантируют ПОРЯДОК элементов

___

3. Map (карта). 

    Коллекция пар «ключ-значение». Каждый ключ уникален, значения могут быть дублированы. Основные реализации: HashMap и TreeMap.

- значения могут быть ДУБЛИРОВАНЫ
- позволяют хранить пары "ключ-значение" 
- и обеспечивают быстрый доступ к значениям по ключу.


![Текст с описанием картинки](Screen2223.png)



## List

   Упорядоченная коллекция элементов, допускающая дубликаты. Основные реализации: ArrayList и LinkedList.

- могут содержить ДУБЛИКАТЫ
- позволяет хранить элементы в определенном ПОРЯДКЕ

Списки обеспечивают доступ к элементам по индексу, что делает их удобными для работы с последовательностями данных.

```java
public static void main(String[] args) {
   List<String> list = new ArrayList<>();
   list.add("Apple");
   list.add("Banana");
   list.add("Apple"); // Дубликаты разрешены

   for (String s : list) {
      System.out.println(s);
   }

   System.out.println();
   System.out.println(list.get(1));
}
```

Вывод:
```java
Apple
Banana
Apple

Banana
```

Списки предоставляют множество методов для работы с элементами, включая:
- добавление
- удаление
- поиск 
- и сортировку. 

Например:
- метод add — позволяет добавлять элементы в список
- метод remove — удалять элементы, 
- а метод contains — проверять наличие элемента в списке.

___


## Set

Интерфейс Set представляет собой коллекцию, которая не содержит дубликатов. 
Основные реализации включают HashSet и TreeSet. 

Множества обеспечивают быстрые операции: 
- добавления
- удаления 
- и поиска, 
- но не гарантируют порядок элементов.

```java
package org.collection.example2;

import java.util.HashSet;
import java.util.Set;

public class Start {

    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("Apple");
        set.add("Banana");
        set.add("Apple"); // Дубликаты не разрешены, "Apple" добавится только один раз

        for (String s : set) {
            System.out.println(s);
        }
    }

}

```

Вывод:
```java
Apple
Banana
```

Множества полезны в ситуациях, когда важно исключить дубликаты. 

Например, при хранении уникальных идентификаторов или при фильтрации повторяющихся элементов из списка.



___


## Map 

Интерфейс Map представляет собой коллекцию пар "ключ-значение". 
Основные реализации включают HashMap и TreeMap. 

Карты позволяют:
- быстро находить значения по ключу 
- и обеспечивают удобный способ хранения связанных данных


```java 
package org.collection.example2;

import java.util.HashMap;
import java.util.Map;

public class Start2 {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Apple", 3); // Значение для ключа "Apple" будет обновлено

        for (String s : map.keySet()) {
            System.out.println(s + " " + map.get(s));
        }
    }

}
```

Вывод:
```java 
Apple 3
Banana 2
```

___
___

## Классы-реализации коллекций: ArrayList, LinkedList, HashSet, HashMap и др.

### ArrayList

ArrayList — это реализация интерфейса List, основанная на массиве.

```java
package org.collection.example1;

import java.util.ArrayList;
import java.util.List;

public class Start4 {

    public static void main(String[] args) {
        List<String> arrayList = new ArrayList<>();
        arrayList.add("Apple");
        arrayList.add("Banana");
        System.out.println(arrayList.get(0)); // Вывод: Apple

        System.out.println();
        for (String s : arrayList) {
            System.out.println(s);
        }
    }

}
```

Вывод:
```java
Apple

Apple
Banana
```

ArrayList является одним из наиболее часто используемых классов коллекций
- ПЛЮС: обеспечивает быстрый доступ к элементам по индексу
- МИНУС: операции вставки и удаления могут быть медленными (особенно при работе с большими объемами данных или в середине списка)


___

### LinkedList

LinkedList — это реализация интерфейса List, основанная на двусвязном списке. 

- МИНУС: доступ по индексу может быть медленным
- ПЛЮС: обеспечивает быстрые операции вставки и удаления

LinkedList подходит для сценариев, где важны частые изменения структуры списка.


LinkedList также поддерживает дополнительные методы - такие как добавление и удаление элементов с начала и конца списка, 
что делает его удобным для реализации очередей и стеков.

```java
package org.collection.example1;

import java.util.LinkedList;
import java.util.List;

public class Start5 {

   public static void main(String[] args) {
      List<String> linkedList = new LinkedList<>();
      linkedList.add("Apple");
      linkedList.add("Banana");
      System.out.println(linkedList.get(0)); // Вывод: Apple

      System.out.println();
      for (String s : linkedList) {
         System.out.println(s);
      }
   }

}

```

Вывод:
```java
Apple

Apple
Banana
```

___

### HashSet

HashSet — это реализация интерфейса Set, основанная на хэш-таблице. 

- ПЛЮСЫ: уникальность элементов
- ПЛЮСЫ: обеспечивает быстрые операции добавления, удаления и поиска, 
- МИНУСЫ: но не гарантирует порядок элементов. 

HashSet полезен для хранения уникальных элементов и быстрого выполнения операций проверки наличия.

HashSet является отличным выбором для задач, 
где важна уникальность элементов и не требуется сохранение порядка. 
Например, для хранения уникальных идентификаторов или фильтрации дубликатов.

```java
package org.collection.example1;

import java.util.HashSet;
import java.util.Set;

public class Start6 {

    public static void main(String[] args) {
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Banana");
        System.out.println(hashSet.contains("Apple")); // Вывод: true

        System.out.println();
        for (String s : hashSet) {
            System.out.println(s);

        }
    }

}
```

Вывод: 
```java
true

Apple
Banana
```


___

### HashMap

HashMap — это реализация интерфейса Map, основанная на хэш-таблице. 

- ПЛЮСЫ: обеспечивает быстрые операции добавления, удаления и поиска по ключу.

HashMap широко используется для хранения и управления парами "ключ-значение".

HashMap предоставляет методы для работы с парами "ключ-значение", такие как:
- put
- get
- remove 
- и containsKey. 

Она является мощным инструментом для реализации различных структур данных и алгоритмов, 
требующих быстрого доступа к данным по ключу.

```java
package org.collection.example1;

import java.util.HashMap;
import java.util.Map;

public class Start7 {

    public static void main(String[] args) {
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("Apple", 1);
        hashMap.put("Banana", 2);
        System.out.println(hashMap.get("Apple")); // Вывод: 1

        System.out.println();
        for (String s : hashMap.keySet()) {
            System.out.println(s + " : " + hashMap.get(s));
        }
    }

}
```

Вывод:
```java
1

Apple : 1
Banana : 2
```

___
___
___

## Основные операции с коллекциями: добавление, удаление, поиск и итерация

### Добавление

Добавление элементов в коллекции осуществляется с помощью
- методов `add` для List и Set
- и метода `put` для Map. 

Эти методы позволяют динамически изменять содержимое коллекций:

```java
list.add("Cherry");
set.add("Cherry");
map.put("Cherry", 3);
```

Добавление элементов в коллекции является одной из наиболее часто выполняемых операций. 

Важно учитывать, что производительность этой операции может варьироваться в зависимости от типа коллекции 
и ее текущего состояния.


### Удаление

Удаление элементов из коллекций осуществляется с помощью методов `remove`. 

Эти методы позволяют удалять элементы по значению или по ключу, 
в зависимости от типа коллекции:

```java
list.remove("Banana");
set.remove("Banana");
map.remove("Banana");
```

Удаление элементов из коллекций может быть полезным для управления памятью и поддержания актуальности данных. 

Например, удаление устаревших записей из списка или карты.


### Поиск

Поиск элементов в коллекциях осуществляется с помощью методов:
- `contains` для List и Set
- `get` для Map

Эти методы позволяют проверять наличие элементов и получать значения по ключу:

```java
boolean containsApple = list.contains("Apple");
boolean containsBanana = set.contains("Banana");
Integer appleValue = map.get("Apple");
```

Поиск элементов в коллекциях является важной операцией для выполнения различных задач, 
таких как проверка наличия данных или извлечение значений по ключу. 

Эффективность поиска зависит от типа коллекции и ее реализации.


### Итерация

Итерация по элементам коллекций осуществляется с помощью циклов `for-each` или итераторов. 

Эти методы позволяют последовательно обрабатывать все элементы коллекции:

```java
for (String item : list) {
    System.out.println(item);
}

for (String item : set) {
    System.out.println(item);
}

for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

Итерация по коллекциям является важной частью работы с данными. 

Она позволяет выполнять различные операции над элементами коллекции, 
такие как вывод на экран, изменение значений или выполнение вычислений.



___
___












# Углубленное изучение коллекций


внутреннее устройство ArrayList

база: что такое ArrayL
принцип работы add и remove

ConcurrentModificationException

iterator

___


1. База: Что такое ArrayList

ArrayList – это динамический массив на базе стандартного массива, реализующий интерфейс List. Основные особенности:

- Хранит элементы в виде массива (Object), при этом размер может меняться динамически.
- Предоставляет быстрый доступ по индексу (через get и set), что дает сложность O(1).
- При добавлении элементов может потребоваться расширение внутреннего массива, что приводит к затратам на копирование.
- Не синхронизирован, поэтому при работе в многопоточной среде требуется дополнительная синхронизация.

Простой пример создания и работы с ArrayList:

```java
import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String args) {
        List<String> fruits = new ArrayList<>();
        fruits.add("Яблоко");
        fruits.add("Банан");
        fruits.add("Апельсин");

        // Обход с использованием цикла for
        for (int i = 0; i < fruits.size(); i++) {
            System.out.println(fruits.get(i));
        }
    }
}
```

___

2. Принцип работы add и remove

Метод add:
- При вызове add(value) элемент добавляется в конец списка.
- Если внутренний массив заполнен, ArrayList создает новый массив с большим размером (обычно увеличивая емкость примерно на 50% — точная стратегия зависит от реализации) и копирует старые элементы.
- Сложность добавления в конец – амортизированная O(1), но если происходит перераспределение – временные затраты возрастают.

Метод remove:
- При вызове remove(index) удаляется элемент по указанному индексу.
- После удаления производится сдвиг всех последующих элементов на одну позицию влево, чтобы «заполнить пробел».
- Это сдвигиная операция имеет сложность O(n) в худшем случае, особенно при удалении элемента в начале списка.
- Алгоритм также обновляет переменную modCount, которая отвечает за контроль модификаций коллекции (используется итераторами).


```java
import java.util.ArrayList;

public class ArrayListAddRemove {
    public static void main(String args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        // Добавление элементов
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        System.out.println("Список после добавления: " + numbers);

        // Удаление элемента по индексу 1 (элемент 2)
        numbers.remove(1);
        System.out.println("Список после удаления элемента по индексу 1: " + numbers);
    }
}
```

___


### Подробнее про Remove

### Удаление элемента в ArrayList и роль модификационного счетчика (modCount)

Предположим, у нас есть ArrayList с элементами. 
При вызове метода remove(index):

a) Проверяется, что индекс находится в пределах текущего размера списка. 
Если индекс неверный, выбрасывается исключение.

b) Сохраняется удаляемый элемент для возможного возврата.

c) Элементы, находящиеся правее удаляемого, сдвигаются на одну позицию влево. 
Для этого используется вызов System.arraycopy. 
Например, если размер списка равен size, 
и удаляется элемент по индексу i, то производится копирование массива следующим образом:

```java
System.arraycopy(elementData, i + 1, elementData, i, size - i - 1);
```

Это означает:
- Начинаем копировать элементы, начиная с позиции i+1.
- Копируем их в позицию i.
- Количество копируемых элементов равно (size - i - 1).

d) Последний элемент (который теперь продублирован) обнуляется (присваивается null), 
чтобы сборщик мусора мог освободить память, 
если на этот объект больше не ссылаются.

e) Уменьшается значение переменной size на 1.

f) Изменяется значение переменной modCount. 
modCount – это счётчик модификаций, который ведёт учёт всех структурных изменений списка 
(например, добавлений, удалений). 
Он используется в итераторах для быстрой проверки, 
не была ли коллекция изменена во время итерации. 
Если во время обхода списка через итератор обнаруживается, 
что modCount изменился, итератор выбросит ConcurrentModificationException, 
сигнализируя о том, что список был модифицирован вне итератора.

Пример упрощённого кода метода remove (для понимания, а не точная копия из JDK):

```java
public E remove(int index) {
    rangeCheck(index);  // проверяем корректность индекса
    E oldValue = elementDataindex;
    
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index + 1, elementData, index, numMoved);
    
    elementData--size = null; // обнуляем ссылку для сборщика мусора
    modCount++;  // увеличиваем счётчик модификаций
    return oldValue;
}
```

Основные моменты:
- Сдвиг элементов – операция, имеющая сложность O(n) в худшем случае 
(например, удаление первого элемента, когда нужно сдвинуть почти все элементы).

- modCount позволяет "защитить" коллекцию от неожиданных изменений во время итерации.



### Когда и как можно использовать удаление элементов

При использовании различных циклов нужно учитывать, 
что изменение коллекции (удаление или добавление элементов) 
может нарушить корректность работы итератора, если коллекция изменяется напрямую.

a) Удаление через `for-each` (расширенный for):

Метод `for-each` использует внутренний итератор. 
Если внутри цикла for-each попытаться вызвать метод `list.remove()`
для текущего списка, то это приведёт к изменению modCount, 
которое не ожидается итератором. В результате итератор при следующей итерации обнаружит несоответствие modCount
и выбросит ConcurrentModificationException.

Пример, чего не стоит делать:

```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
for (String s : list) {
    if (s.equals("b"))
        list.remove(s); // Неверно!
}
```

НО ПРИ ЭТОМ ОШИБКИ НЕТ

ДЕЛО В ТОМ ЧТО ОН ВТОРОЙ БЫЛ, вот так проявится:

```java
ArrayList<String> list = new ArrayList<>(List.of("a", "b", "c", "d", "e", "f"));
for (String s : list) {
    if (s.equals("b"))
        list.remove(s); // Неверно!
}
```

___

b) Правильные способы удаления элементов во время итерации:

Вариант 1. Использовать итератор и его метод remove(), 
который корректно обновляет внутреннее состояние итератора:

```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String s = it.next();
    if (s.equals("b"))
        it.remove();  // Удаляем через итератор
}
```

А РАНЬШЕ Я УДАЛЯЛ ВЫХОДИТ НЕВЕРНО?
кажется мог делать через break...

___

Вариант 2. Использовать цикл обхода с индексом, если модификация коллекции напрямую 
(но при этом нужно правильно управлять индексами, чтобы не пропустить элементы):

```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
for (int i = 0; i < list.size(); i++) {
    if (list.get(i).equals("b")) {
        list.remove(i);
        i--;  // корректировка индекса, чтобы не пропустить следующий элемент
    }
}
```

// так я ни разу не делал - занятно

// но почему тут нет конфликт с mocCount? мы не используем удаление через итератор тут 
// имеется ввиду, что мы тут просто напросто учитываем изменение размера листа и поэтому все ок?  

___


Вариант 3. Использовать метод removeIf, появившийся в Java 8, 
который безопасно удаляет элементы по условию:

```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
list.removeIf(s -> s.equals("b"));
```

Кратко:
- Удалять элементы напрямую в цикле for-each нельзя – это приводит к исключениям.
- Если нужно удалять элементы во время обхода коллекции, лучше использовать итератор (и его remove()) или специальные методы коллекции (например, removeIf).


Заключение:

- Удаление элемента в ArrayList включает сдвиг всех последующих элементов на одну позицию влево с использованием System.arraycopy. При этом обновляется переменная modCount, которая используется для контроля одновременных модификаций коллекции.
- При обходе коллекций важно не изменять структуру коллекции напрямую (например, через list.remove()) во время использования for-each, а применять корректные методы удаления через итератор или другие подходы.

ВОПРОСЫ ПАША:
1. у нас в каждом из 3 "верных" вариантов удаления использовался modCount?
2. modCount как работает? запуск программы и он равен значению = 0?
3. затем в ходе работы программы при изменении размера листа (именно размера? доб/удал?) у нас происходит ++ ?

















___
___
___
```java
```
___
___
___
___
___






3. ConcurrentModificationException

ConcurrentModificationException – это исключение, которое выбрасывается в случае,
когда коллекция была модифицирована структурно (то есть добавлены или удалены элементы),
кроме как через методы итератора, во время итерации. Это связано с так называемым принципом «fail-fast».

Как это работает:
- ArrayList содержит переменную modCount, которая увеличивается при каждой структурной модификации.
- Итератор при создании сохраняет значение modCount.
- Перед каждой операцией next() итератор проверяет, что значение modCount не изменилось.
  Если обнаруживается разница, то выбрасывается ConcurrentModificationException.


```java
import java.util.ArrayList;
import java.util.Iterator;

public class ConcurrentModificationExample {
    public static void main(String args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        try {
            for (String item : list) {
                // Попытка модификации коллекции во время итерации
                if ("B".equals(item)) {
                    list.remove(item); // Это вызовет ConcurrentModificationException
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("Исключение: " + e);
        }
    }
}
```
ОБСУДИТЬ - У МЕНЯ НЕ ВЫШЛО ConcurrentModificationException, ПОЧЕМУ? 


Рекомендации для безопасного удаления элементов во время итерации:
- Использовать метод remove() итератора.
- Либо копировать коллекцию в новый список и работать с ней.

Пример безопасного удаления:


```java
import java.util.ArrayList;
import java.util.Iterator;

public class SafeRemoveExample {
    public static void main(String args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        Iterator<String> it = list.iterator();
        while (it.hasNext()) {
            String item = it.next();
            if ("B".equals(item)) {
                it.remove(); // Безопасное удаление через итератор
            }
        }

        System.out.println("Список после безопасного удаления: " + list);
    }
}
```


___

4. Iterator

Iterator – это объект, предоставляющий способ последовательного обхода элементов коллекции. Он поддерживает методы:
- hasNext() – проверяет, есть ли следующий элемент;
- next() – возвращает следующий элемент;
- remove() – удаляет текущий элемент, на который указывает итератор, предотвращая возникновение ConcurrentModificationException при корректном использовании.

Некоторые моменты:
- Итераторы реализуют fail-fast механизм, как описано выше, поэтому любые структурные изменения вне итератора могут вызвать исключение.
- Итератор позволяет абстрагироваться от внутренней структуры коллекции и работает как универсальный интерфейс для обхода.

Пример использования итератора для обхода коллекции:



```java
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorExample {
    public static void main(String args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Первый");
        list.add("Второй");
        list.add("Третий");

        // Использование итератора для обхода элементов
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String element = iterator.next();
            System.out.println(element);
        }
    }
}
```


Важно: Итератор позволяет корректно выполнять операции удаления с использованием метода remove(),
который обновляет внутреннее состояние итератора и коллекции, избегая конфликтов с modCount.


Вывод

Изучая углубленно коллекции в Java, необходимо понимать:
- Внутреннюю структуру таких классов, как ArrayList, и как они реализуют динамические массивы.
- Как работают методы add (с динамическим расширением) и remove (сдвиг элементов и обновлением modCount).
- Почему возникает ConcurrentModificationException и как избежать ошибок при изменении коллекции во время итерации.
- Роль итератора в обходе коллекций, его fail-fast поведение и возможности безопасного удаления элементов.

Эти концепции являются основой для эффективной работы с коллекциями в Java и понимания их внутренней реализации,
что особенно полезно при оптимизации производительности и разработке потокобезопасного кода.


___
___
___



# equals() и hashCode() 

В Java методы equals() и hashCode() играют ключевую роль
- в сравнении объектов 
- и работе с коллекциями, такими как HashMap, HashSet и другими.


## equals():

- Метод используется для сравнения объектов на равенство. 

    
- По умолчанию он сравнивает ссылки (адреса объектов в памяти), 
    
    // но обычно его переопределяют, чтобы сравнивать поля объектов.

Например:


```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        Person other = (Person) obj;
        return name.equals(other.name) && age == other.age;
    }

    public static void main(String[] args) {
        Person person1 = new Person("Nik", 6);
        Person person2 = new Person("Jak", 7);
        System.out.println(person1.equals(person1));
        System.out.println(person1.equals(person2));
    }
}
```

instanceof — это оператор сравнения типов, 
- который используется для проверки того, относится ли объект к заданному типу (классу, подклассу или интерфейсу)
- Он возвращает логическое значение true, если объект является экземпляром указанного класса или интерфейса 
- в противном случае — false


ОБСУДИТЬ ПРИМЕР ВЫШЕ С ПАШЕЙ












## hashCode()

Этот метод:
- возвращает целочисленный код хеширования объекта
- который используется, например, в хеш-таблицах
- когда вы переопределяете equals(), вам также нужно переопределить hashCode(), чтобы обеспечивать согласованность.

Вот пример переопределения hashCode():

```java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}

```




## Почему это важно:

Если вы добавите объекты класса Person в HashSet, то он будет использовать hashCode() для поиска объектов. 

Если equals() и hashCode() не соответствуют друг другу, может произойти ситуация, когда два равных объекта будут считаться разными в коллекции.

Пример использования:

```java
Set<Person> people = new HashSet<>();
people.add(new Person("Alice", 30));
people.add(new Person("Alice", 30)); // Этот объект будет игнорирован

System.out.println(people.size()); // Выведет 1

```

Таким образом, правильно реализованные методы equals() и hashCode() обеспечивают корректное поведение коллекций, основанных на хешировании.

___

Еще раз:

## 1. Суть методов equals и hashCode

а) Метод equals(Object obj):
- Позволяет определить, равны ли два объекта по содержимому.  
- По умолчанию реализация (наследуемая от Object) сравнивает ссылки (то есть, obj1.equals(obj2) будет true только если obj1 == obj2).  
- Обычно `переопределяют в собственных классах, если хотят, чтобы объекты считались равными по значению` (например, если поля совпадают).

б) Метод hashCode():
- Возвращает числовое значение (целое число), которое используется для оптимизации поиска в хэш-коллекциях.  
- Основная идея: если два объекта равны согласно equals, они должны возвращать один и тот же hashCode. Это называется контрактом hashCode/equals.



## 2. Контракт hashCode и equals

Контракт гласит:
- Если два объекта равны посредством equals, то их hashCode должен быть одинаковым.  
- Если hashCode у двух объектов различен, объекты гарантированно не равны.  
- Однако, одинаковый hashCode не гарантирует равенство, то есть могут быть коллизии.

Почему это важно? 

Например, HashSet использует hashCode для размещения объектов в бакетах (корзинах). 

При добавлении объекта сначала вычисляется его hashCode, который помогает быстро локализовать где могут находиться эквивалентные объекты. 

Далее, если бакет найден, вызывается equals для точного сравнения.




## 3. Пример: переопределение equals и hashCode

Рассмотрим класс Person с полями name и age. 

Чтобы два объекта Person считались равными, если у них одинаковые имя и возраст, необходимо переопределить equals и hashCode.

Пример кода:

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Переопределяем equals
    @Override
    public boolean equals(Object obj) {
        // Проверка на самосравнение
        if (this == obj) return true;
        // Если передали null или объекты разных классов, считаем их не равными
        if (obj == null || getClass() != obj.getClass()) return false;
        Person other = (Person) obj;
        // Сравниваем по значимым полям
        return age == other.age &&
               (name != null ? name.equals(other.name) : other.name == null);
    }

    // Переопределяем hashCode
    @Override
    public int hashCode() {
        int result = 17; // произвольное начальное число
        result = 31 * result + age;
        result = 31 * result + (name != null ? name.hashCode() : 0);
        return result;
    }
    
    // Для удобства выводим объект в консоль
    @Override
    public String toString() {
        return "Person{name='" + name + '\'' + ", age=" + age + '}';
    }

    public static void main(String[] args) {
        Person person1 = new Person("John", 20);
        System.out.println(person1);
        System.out.println(person1.toString());

        Person person2 = new Person("Joe", 22);
        System.out.println(person1.equals(person1));
        System.out.println(person1.equals(person2));
    }
    
}
```

С ПАШЕЙ ПРОЙТИСЬ ПО ПРИМЕРУ 


Объяснения:
- equals сначала проверяет, не сравниваем ли мы объект сам с собой (this == obj), затем – на null и совпадение классов.
- После этого происходит сравнение значимых полей.
- hashCode вычисляется на основе тех же полей, что и в equals. Использование простых чисел (например, 17 и 31) – стандартный подход для расчёта.




## 4. Пример использования в коллекциях

Рассмотрим, как два объекта Person ведут себя в HashSet.

```java
import java.util.HashSet;
import java.util.Set;

public class Main {
    
    public static void main(String args) {
        Person person1 = new Person("Alice", 30);
        Person person2 = new Person("Alice", 30);
        Person person3 = new Person("Bob", 25);

        Set<Person> set = new HashSet<>();
        set.add(person1);
        set.add(person2);
        set.add(person3);

        System.out.println("Размер множества: " + set.size());
        for (Person p : set) {
            System.out.println(p);
        }
    }
    
}
```

Вывод:
```java
Размер множества: 2
Person{name='Alice', age=30}
Person{name='Bob', age=25}
```

Если equals и hashCode переопределены корректно:
- то person1 и person2 будут считаться одинаковыми
- и в HashSet останется только один экземпляр со значениями ("Alice", 30)
- соответственно, размер множества будет 2


Если бы не переопределять equals/hashCode, 
- то даже если поля одинаковы, объекты считались бы разными (так как сравнивались бы ссылки), 
- а HashSet добавил бы оба, что приводит к логике, отличной от ожидаемой.



___

Еще пример:

```java
package org.collection.example3;

import java.util.HashSet;
import java.util.Set;

public class Start2 {

    public static void main(String[] args) {
        Person person1 = new Person("Alice", 30);
        Person person2 = new Person("Alices", 30);
        Person person3 = new Person("Bob", 25);
        Person person4 = new Person("Bob", 26);

        Set<Person> set = new HashSet<>();
        set.add(person1);
        set.add(person2);
        set.add(person3);
        set.add(person4);

        System.out.println("Размер множества: " + set.size());
        for (Person p : set) {
            System.out.println(p);
        }

    }

}

```

Вывод: 
```java
Размер множества: 4
Person{name='Alice', age=30}
Person{name='Alices', age=30}
Person{name='Bob', age=25}
Person{name='Bob', age=26}
```



## 5. Основные ошибки при переопределении

- Несоответствие между equals и hashCode. Если переопределить только equals, можно столкнуться с проблемой, когда два объекта равны, но имеют разные hashCode – это приводит к ошибкам при использовании в хэш-коллекциях.  
- Не учитывать все значимые поля, используемые для сравнения. Например, если в equals используются поля name и age, они должны участвовать и в вычислении hashCode.  
- Использование изменяемых значений для вычисления hashCode. Если объект изменится после добавления в HashSet, поведение коллекции может оказаться некорректным, так как hashCode уже не совпадёт с первоначально вычисленным.






## 6. Дополнительный пример: ошибки при использовании изменяемых полей

Представьте ситуацию, где после помещения объекта в HashSet мы изменим значение поля, участвующего в вычислении hashCode. 

Это может привести к тому, что объект окажется в неверном бакете коллекции, и его уже не удастся найти или удалить.


```java
package org.collection.example4;

public class MutablePerson {
    private String name;

    public MutablePerson(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        MutablePerson other = (MutablePerson) obj;
        return name != null ? name.equals(other.name) : other.name == null;
    }

    @Override
    public int hashCode() {
        return name != null ? name.hashCode() : 0;
    }

    @Override
    public String toString() {
        return "MutablePerson{name='" + name + "'}";
    }

}


```

```java
package org.collection.example4;

import java.util.HashSet;
import java.util.Set;

public class Start {

    public static void main(String[] args) {
        Set<MutablePerson> set = new HashSet<>();
        MutablePerson p = new MutablePerson("Alice");
        set.add(p);
        System.out.println("До изменения: " + set.contains(p)); // true
        // Изменяем поле, влияющее на hashCode
        p.setName("Bob");
        System.out.println("После изменения: " + set.contains(p)); // Может быть false!
    }

}

```

В данном примере, 
- после изменения имени, hashCode объекта изменится, 
- а HashSet не сможет корректно определить, что этот объект уже находится в коллекции. 

Это приводит к трудноуловимым багам.







## 7. Итог

- equals позволяет сравнивать объекты по содержимому, а hashCode обеспечивает быструю индексацию в хэш-структурах.  
- Их совместное переопределение обязательно: если equals возвращает true для двух объектов, их hashCode должны совпадать.  
- Правильное проектирование этих методов особенно важно при использовании объектов в коллекциях, основанных на хэшировании.

___
___
___











## Что такое имутабельный объект / тип данных / класс?

### 1. Что такое неизменяемый (immutable) объект / тип данных / класс?

Неизменяемый объект 
– это такой объект, состояние которого (т.е. значения всех его полей) нельзя изменить после создания. 

Другими словами, после инициализации объекта - его внутреннее состояние остается постоянным на протяжении всего времени жизни объекта. 

Примеры неизменяемых объектов в Java:
- класс String, классы-оболочки (например, Integer, Boolean) и т.д. 
- это свойство помогает избежать проблем с синхронизацией в многопоточной среде и делает объекты безопасными для хранения в коллекциях (например, в качестве ключей в HashMap, при условии, что их hashCode не изменится).

___

### 2. Как создать неизменяемый объект / тип данных / класс?

Чтобы создать неизменяемый класс в Java, обычно придерживаются следующих правил:

• Сделать класс финальным (final) или так спроектировать его, 
чтобы его нельзя было наследовать и изменять поведение. 
(Иногда final не обязателен, если класс корректно спроектирован, но объявление его final усложняет изменение поведения через наследование.)

• Все поля класса должны быть объявлены как private и final. 
Это гарантирует, что они могут быть инициализированы только один раз – в конструкторе.

• Не предоставлять методов-сеттеров (setter’ов) или любых других методов, 
которые могли бы изменить внутреннее состояние объекта.

• Если объект содержит ссылки на изменяемые объекты (например, Date или коллекции), то:
- в конструкторе необходимо создавать копии переданных объектов (defensive copy),
- геттеры также должны возвращать копии, а не сами ссылки на внутренние изменяемые объекты.


Пример 1:

```java
public final class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}
```

Комментарий:
- Класс объявлен как final, значит, его нельзя наследовать.
- Поля x и y – private и final, устанавливаются только в конструкторе.
- Методы getX() и getY() предоставляют доступ к значениям, но их изменить нельзя.

___

Пример 2. Неизменяемый класс с изменяемым полем (например, с датой):

```java
public final class Person {
    private final String name;
    private final Date birthDate; // Date – изменяемый класс

    public Person(String name, Date birthDate) {
        this.name = name;
        // Создаем копию объекта Date для защиты внутреннего состояния
        this.birthDate = new Date(birthDate.getTime());
    }

    public String getName() {
        return name;
    }

    public Date getBirthDate() {
        // Возвращаем копию, а не оригинальный объект
        return new Date(birthDate.getTime());
    }
}
```

Комментарий:
- В конструкторе мы создаем defensive copy объекта Date, чтобы случайный внешний доступ к исходной дате не мог повлиять на внутреннее состояние объекта Person.
- Также в методе getBirthDate() возвращается копия, чтобы потребитель не мог изменить дату, получив прямую ссылку на внутренний объект.

___  

Итог:

Неизменяемый объект – это объект, который нельзя изменить после его создания.

- Создать неизменяемый класс можно, объявив класс final, сделав все поля private final и не предоставляя методов для изменения состояния.
- Если класс содержит изменяемые объекты, нужно использовать defensive copy при установке и возврате значений.

___
___
___





# Внутреннее устройство HashMap

### 1. Основная идея HashMap

HashMap – это коллекция, которая хранит элементы в виде пар «ключ-значение». 

В основе HashMap лежит массив (называемый «table») с «ведрами» (buckets). 

Когда вы добавляете элемент:
- вычисляется хэш-код ключа
- а затем по нему определяется индекс в массиве (обычно через операцию «hash & (n - 1)», где n – длина массива, которая всегда является степенью двойки). 
- это позволяет очень быстро (почти за O(1)) находить нужное значение.

ПАША: не очень понятно про индекс в массиве..


___


### 2. Роль equals и hashCode

hashCode:
- Каждый объект в Java имеет метод hashCode, который возвращает целое число.
- Когда мы добавляем ключ в HashMap, его hashCode (с некоторыми дополнительными преобразованиями) используется для вычисления индекса в массиве.
- Хорошая реализация hashCode должна равномерно распределять объекты по «ведрам», чтобы избежать слишком большого количества коллизий.


equals:
- Если два объекта имеют одинаковый hashCode, они попадают в один и тот же «bucket».
- На этом этапе, когда, например, происходит поиск элемента, HashMap перебирает все записи в выбранном «ведре» и для поиска нужного ключа использует метод equals.
- Если equals возвращает true, то ключ считается найденным, даже если их hashCode равны.

Важно: контракт между hashCode и equals гласит, 
- что если два объекта равны (equals возвращает true), 
- то их hashCode должны быть одинаковыми. 
- если этот контракт нарушается, HashMap может работать неправильно (например, не найти элемент).


___

### 3. Алгоритм работы при добавлении элемента

Рассмотрим, что происходит при вызове метода put(key, value):

а) Вычисляется хэш-код ключа: key.hashCode() и далее hash(key) – часто с дополнительными перемешиваниями битов для повышения равномерности распределения.

б) Определяется индекс в массиве: index = hash(key) & (capacity - 1).

в) Если в массиве по данному индексу пусто (bucket пустой), то создается новый узел (Node), содержащий key, value, hash и ссылка на следующий узел (при коллизиях).

г) Если там уже находится один или несколько узлов, HashMap проходит по цепочке и:
- Если найден узел, для которого key.equals(ужезаключенныйключ) возвращает true, то значение перезаписывается.
- Если такой записи нет, новый узел добавляется в начало (или конец) списка данного «ведра».
- Начиная с Java 8, если длина списка становится большой (например, более 8 элементов) и размер таблицы больше определенного порога, список превращается в красно-черное дерево для повышения скорости поиска.


ПАША: what?


___

### 4. Пример: корректное переопределение equals и hashCode

Представим класс, который мы будем использовать в качестве ключа в HashMap. 

Если методы equals и hashCode переопределены правильно, то наш ключ будет работать как ожидалось.


```java
public final class Employee {
    private final int id;
    private final String name;

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Переопределяем hashCode – обычно используют множитель и сумму полей
    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + id;
        result = 31 * result + (name != null ? name.hashCode() : 0);
        return result;
    }

    // Переопределяем equals – сравниваем поля, по которым определяем уникальность
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;  // быстрая проверка на равенство по ссылке
        if (obj == null || getClass() != obj.getClass()) return false;
        Employee other = (Employee) obj;
        return id == other.id && (name == null ? other.name == null : name.equals(other.name));
    }
}
```

Комментарий:
- В этом примере мы используем два поля id и name для вычисления hashCode и сравнения equals. Благодаря контракту: если два сотрудника равны по id и name, они получат одинаковый hashCode, а equals вернет true.
- Такой класс можно безопасно использовать в качестве ключа в HashMap, потому что его состояние не изменяется после создания (класс можно сделать неизменяемым, как показано).





___

### 5. Пример использования HashMap с учетом equals и hashCode

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String args) {
        Map<Employee, String> employeeMap = new HashMap<>();

        Employee emp1 = new Employee(1, "Alice");
        Employee emp2 = new Employee(2, "Bob");
        Employee emp3 = new Employee(1, "Alice"); // Такой же "ключ", как и emp1

        employeeMap.put(emp1, "Разработчик");
        employeeMap.put(emp2, "Тестировщик");

        // Попытаемся добавить emp3; поскольку emp1.equals(emp3) должно вернуть true,
        // значение для ключа с id=1 и name="Alice" будет перезаписано.
        employeeMap.put(emp3, "Ведущий разработчик");

        // Получаем значение по ключу emp1
        System.out.println("Должно вывести 'Ведущий разработчик': " + employeeMap.get(emp1));
        // Также можно найти по emp3, так как они равны
        System.out.println("Должно вывести 'Ведущий разработчик': " + employeeMap.get(emp3));
    }
}
```

Комментарий:

- При добавлении emp3 HashMap использует hashCode, чтобы найти «ведро», а затем equals, чтобы сравнить emp3 с уже хранящимся emp1.
- В итоге значение для данного ключа обновляется на "Ведущий разработчик", что мы и наблюдаем при извлечении.


___


### 6. Дополнительно: как выглядит структура узла (Node)

Внутри HashMap, начиная с Java 8, используется вспомогательный класс Node, который обычно реализован так (упрощенный вариант):

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next; // ссылка на следующий элемент в ведре (при коллизиях)

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    @Override
    public final K getKey() { return key; }
    @Override
    public final V getValue() { return value; }
    @Override
    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    // equals и hashCode для Entry тоже переопределяются по контракту
}
```

Комментарий:
- Каждый узел содержит вычисленный хэш, сам ключ, значение и ссылку на следующий узел в списке, если в одном «ведре» оказывается несколько элементов.
- При поиске нужного ключа HashMap сначала определяет индекс и затем проходит по цепочке, сравнивая с помощью equals.




___

### Итог

HashMap использует методы hashCode для распределения ключей по массиву, 

А метод equals для определения истинного равенства ключей в случае коллизий. 

Правильное переопределение equals и hashCode является обязательным условием для корректной работы HashMap (а также других коллекций, использующих хэширование, например HashSet).






___
___
___

```java
```

