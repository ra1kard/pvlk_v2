# Метод в Java

Метод в Java – это комплекс выражений, 
совокупность которых позволяет выполнить определенную операцию. 

Так, например, при вызове метода System.out.println(), 
система выполняет ряд команд для выведения сообщения на консоль.

## Создание метода

```java
public static int methodName(int a, int b) {
// тело
}
```
Где,
- public static – модификатор;
- int – возвращаемый тип;
- methodName – имя метода;
- a, b – формальные параметры;
- int a, int b – перечень параметров.

## Вызов метода

Перед использованием метода его необходимо вызвать.

- метод может возвращать значение
- либо не возвращать ничего (void - отсутствует возвращающее значение)

Алгоритм вызова метода достаточно прост. 
Когда программа производит в Java вызов метода, программное управление передается вызванному методу. 
Данный вызванный метод затем возвращает управление вызывающему клиенту в двух случаях, если:
1. выполняется оператор возврата;
2. достигнута закрывающая фигурная скобка окончания метода.

### пример - создание и вызов метода

```java
public class Example1 {

    public static int minFunction(int n1, int n2) {
        int min;
        if (n1 > n2)
            min = n2;
        else
            min = n1;
        return min;
    }

    public static void main(String[] args) {
        System.out.println(minFunction(5, 10));
        System.out.println(minFunction(13, 10));
    }

}
```

## Ключевое слово void

Ключевое слово void в Java позволяет нам создать методы, не производящие возврат значения.

Пример когда мы просто выводим результат на экран:

```java
public class ExampleVoid {

   public static void main(String[] args) {
      methodRankPoints(255.7);
   }

   public static void methodRankPoints(double points) {
      if (points >= 202.5) {
         System.out.println("Ранг A1");
      }else if (points >= 122.4) {
         System.out.println("Ранг A2");
      }else {
         System.out.println("Ранг A3");
      }
   }
}
```

## Передача параметров по значению

Что такое Параметры и Аргументы:
- Параметры - это переменные, объявленные в определении функции.
- Аргументы - это значения, передаваемые функции при ее вызове.

При выполнении вызывающего процесса производится в Java передача аргументов. 
Процедура должна осуществляться согласно порядку, 
предусмотренному соответствующими параметрами в спецификации метода. 

Передача параметров может производиться:
- по значению
- либо по ссылке.

В Java передача параметров по значению обозначает вызов метода с параметром. 
За счет этого производится передача значения аргумента параметру.

```java
public class swappingExample {

    public static void main(String[] args) {
        int a = 30;
        int b = 45;
        System.out.println("Перед тем как передать, значения аргументов a = " + a + " и b = " + b);

        // Вызов метода передачи
        swapFunction(a, b);
        System.out.println("\nСейчас, до и после передачи значения аргументов ");
        System.out.println("остались неизменными, a = " + a + " и b = " + b);
    }

    public static void swapFunction(int a, int b) {
        System.out.println("До замены: a = " + a + " b = " + b);

        // Передача параметров
        int c = a;
        a = b;
        b = c;
        System.out.println("После замены: a = " + a + " b = " + b);
    }

}
```
Получим следующий результат:

```java
Перед тем как передать, значения аргументов a = 30 и b = 45
До замены: a = 30 b = 45
После замены: a = 45 b = 30

Сейчас, до и после передачи значения аргументов
остались неизменными, a = 30 и b = 45
```

## Перегрузка методов

Перегрузка методов в Java – случай, 
когда в классе присутствуют два и более метода с одинаковым именем, но различными параметрами. 
Данный процесс отличен от переопределения методов. 

При переопределении методов, метод характеризуется аналогичным именем, типом, числом параметров и т.д.

Пример:

```java
public class ExampleOverloading {

    public static void main(String[] args) {
        int a = 7;
        int b = 3;
        double c = 5.1;
        double d = 7.2;
        int result1 = minFunction(a, b);

        // такая же функция с другими параметрами
        double result2 = minFunction(c, d);
        System.out.println("Минимальное значение = " + result1);
        System.out.println("Минимальное значение = " + result2);
    }

    // для integer
    public static int minFunction(int n1, int n2) {
        int min;
        if (n1 > n2)
            min = n2;
        else
            min = n1;

        return min;
    }

    // для double
    public static double minFunction(double n1, double n2) {
        double min;
        if (n1 > n2)
            min = n2;
        else
            min = n1;

        return min;
    }
    
}
```

В итоге будет получен следующий результат:

```Java
Минимальное значение = 3
Минимальное значение = 5.1
```

Методы перегрузки делают программу читаемой. 
Таким образом, представлены два метода с одинаковым именем, но различными параметрами. 
В результате чего мы получили минимальные int число и число double типа.

## Переопределение (override)

В предыдущей главе мы рассказали про суперклассы и подклассы. 
Если класс наследует метод из своего суперкласса, 
тогда есть шанс переопределить взятый метод, если он не помечен final. 
(https://proglang.su/java/overriding)

Так что такое в Java overriding или override – это переопределение.

Преимущество в Java переопределения заключается в том, 
что оно позволяет определять (описывать) поведение, характерное для типа подкласса, 
значит подкласс может реализовать метод родительского класса на основе его требования.

В объектно-ориентированных терминах, 
переопределение значит перезапись функционала существующего метода.

### Пример 1: 
```Java
class Animal {
   public void move() {
      System.out.println("Животные могут двигаться");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Собаки могут ходить и бегать");
   }
}

public class TestDog {

   public static void main(String args[]) {
      Animal a = new Animal();   // Animal - ссылка и объект
      Animal b = new Dog();      // Animal - ссылка, но Dog - объект

      a.move();   // Запускает метод в классе Animal
      b.move();   // Запускает метод в классе Dog
   }
}
```

После запуска программы будет выдан такой результат:
```Java
Животные могут двигаться
Собаки могут ходить и бегать
```

В вышеприведённом примере вы можете заметить, что b хоть и является типом Animal, 
оно запускает метод move в классе Dog. 
Причина тому: во время компиляции проходит проверка ссылочного типа. 
Однако, во время выполнения, JVM определяет тип объекта и запускает метод, 
который принадлежит этому конкретному объекту.

Следовательно, по примеру выше, программа запустится правильно, 
так как класс Animal имеет метод move. Затем, во время выполнения, он запускает метод, 
принадлежащий этому объекту.

### Пример 2:

```Java
class Animal {
   public void move() {
      System.out.println("Животные могут двигаться");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Собаки могут ходить и бегать");
   }
   public void bark() {
      System.out.println("Собаки могут лаять");
   }
}

public class TestDog {

   public static void main(String args[]) {
      Animal a = new Animal();   // Animal - ссылка и объект
      Animal b = new Dog();   // Animal - ссылка, но Dog - объект

      a.move();   // Запускает метод в классе Animal
      b.move();   // Запускает метод в классе Dog
      b.bark();
   }
}
```

После запуска программы будет выдан такой результат:
```Java
TestDog.java:26: error: cannot find symbol
      b.bark();
       ^
  symbol:   method bark()
  location: variable b of type Animal
1 error
```

Программа выдаст ошибку во время компиляции, 
так как ссылочный тип b у Animal не имеет метода под именем bark.

### Правила переопределения метода

- Список аргументов должен быть точно таким же, как и для переопределённого метода.
- Возвращаемый тип должен быть таким же или подтипом возвращаемого типа, объявленного в исходном переопределенном методе в суперклассе.
- Уровень доступа не может быть более ограниченным, чем уровень доступа переопределённого метода. Например, если метод суперкласса объявлен public, то переопределяемый метод в подклассе не может быть private или protected.
- Методы экземпляров могут быть переопределены только если они наследованы подклассом.
- Методы, которые объявлены как final, не могут быть переопределены.
- Статические методы, которые объявлены как static, не могут быть переопределены, но могут быть повторно объявлены.
- Если метод нельзя наследовать, то его нельзя переопределить.
- Подкласс внутри того же пакета, что и суперкласс экземпляра, может переопределять любой метод суперкласса, который не объявлен как private или final.
- Подкласс в другом пакете может переопределять только не final методы, объявленные как public или protected.
- Переопределяемый метод может выдавать любые непроверенные исключения вне зависимости от того, переопределяет ли переопределённый метод какие-либо непроверенные исключения или нет. Однако, переопределяемый метод не должен генерировать проверенные исключения, которые являются новыми или более широкими, чем те, которые объявлены переопределённым методом. Переопределенный метод может генерировать более узкие или меньшие исключения, чем переопределенный метод.
- Конструкторы нельзя переопределить.

### Использование ключевого слова super

Вызывая версию суперкласса переопределённого метода, используется ключевое слово super.

Пример:

```Java
class Animal {
   public void move() {
      System.out.println("Животные могут двигаться");
   }
}

class Dog extends Animal {
   public void move() {
      super.move();   // Вызывает метод суперкласса
      System.out.println("Собаки могут ходить и бегать");
   }
}

public class TestDog {

   public static void main(String args[]) {
      Animal b = new Dog();   // Animal - ссылка, но Dog - объект
      b.move();   // Запуск метода в классе Dog
   }
}
```

После запуска программы будет выдан такой результат:
```Java
Животные могут двигаться
Собаки могут ходить и бегать
```




## Конструктор

В Java конструктор инициализирует объект при его создании. 
Его имя аналогично имени класса, а синтаксис сходен с синтаксисом метода. 
Однако, в отличие от последнего, в конструкторе отсутствует возвращаемое значение.

Результатом работы этого метода всегда является экземпляр класса. 
Следовательно, конструктор класса Cat называется Cat().

Конструкторы присутствуют во всех классах, независимо от их указания, 
в виду того, что Java автоматически предоставляет конструктор по умолчанию, 
который инициализирует все переменные членов класса до нуля. 
Вместе с этим, после того как вы определите собственный конструктор, 
конструктор по умолчанию больше не будет задействован.

### Пример без параметров:

В примере ниже рассмотрено использование конструктора класса без параметров.

```Java
public class MyClass {
    int x;

    // Далее следует конструктор
    MyClass() {
        x = 10;
    }
}
```

Для инициализации объектов вам необходимо выполнить вызов конструктора согласно следующему примеру:

```Java
public class ConsDemo {

    public static void main(String args[]) {
        MyClass t1 = new MyClass();
        MyClass t2 = new MyClass();
        System.out.println(t1.x + " " + t2.x);
    }

}
```

Получим результат:

```Java
10 10
```

### Пример с параметром:

```Java
public class MyClass2 {
    int x;

    // Ниже конструктор
    MyClass2(int i) {
        x = i;
    }
}
```

Для инициализации объектов вам необходимо выполнить вызов конструктора согласно следующему примеру:

```Java
public class ConsDemo2 {

    public static void main(String args[]) {
        MyClass2 t1 = new MyClass2(10);
        MyClass2 t2 = new MyClass2(20);
        System.out.println(t1.x + " " + t2.x);
    }
    
}
```

Получим результат:

```Java
10 10
```

## Ключевое слово this

Ключевое слово this – используется для ссылки на текущий класс с учетом метода или конструктора экземпляра. 
Используя this в Java, Вы можете ссылаться на экземпляры класса, такие как конструкторы, переменные и методы.

Как правило, ключевое слово this в Java используется для:
- дифференцирования между переменными экземпляра и локальными переменными в случае, 
если у них одинаковые имена, в составе конструктора или метода:

```Java
class Student {
    int age;
    
    Student(int age) {
        this.age = age;
    }
}
```

- вызова конструктора одного типа (параметризованного конструктора либо конструктора по умолчанию) 
из другого в составе класса. Данный процесс также носит название явного вызова конструктора:

```Java
class Student {
    int age;
    
    Student() {
        this(20);
    }

    Student(int age) {
        this.age = age;
    }
}
```

### Пример

Далее представлен пример, в котором ключевое слово this используется для доступа к экземплярам класса. 
Необходимо копировать и вставить данную программу в файл с названием This_Example.java.

```Java
public class This_Example {
    // Инициализация переменной num
    int num = 11;

    This_Example() {
        System.out.println("Это пример программы с ключевым словом this");
    }

    This_Example(int num) {
        // Вызов конструктора по умолчанию
        this();

        // Присвоение локальной переменной num переменной экземпляра num
        this.num = num;
    }

    public void greet() {
        System.out.println("Привет! Добро пожаловать на ProgLang!");
    }

    public void print() {
        // Локальная переменная num
        int num = 20;

        // Вызов метода класса greet
        this.greet();

        // Вывод локальной переменной.
        System.out.println("Значение локальной переменной num: " + num);

        // Вывод переменной экземпляра.
        System.out.println("Значение переменной экземпляра num: " + this.num);
    }

    public static void main(String[] args) {
        // Инициализация класса
        This_Example obj1 = new This_Example();

        // Вызов метода print
        obj1.print();

        // Передача нового значения переменной num через параметризованный конструктор
        This_Example obj2 = new This_Example(30);

        // Вызов снова метода print
        obj2.print();
    }

}
```

```Java
Это пример программы с ключевым словом this 
Привет! Добро пожаловать на ProgLang!
Значение локальной переменной num: 20
Значение переменной экземпляра num: 11
Это пример программы с ключевым словом this
Привет! Добро пожаловать на ProgLang!
Значение локальной переменной num: 20
Значение переменной экземпляра num: 30
```


## Метод finalize()

Метод finalize() – метод, который будет вызываться непосредственно перед окончательным 
уничтожением объекта сборщиком мусора. (финализатором). 
В Java finalize() может быть использован для обеспечения чистого завершения объекта.

К примеру, мы можете использовать finalize() чтобы удостовериться в том, что открытый файл, 
принадлежащий данному объекту, был закрыт.

Для добавления финализатора в класс, вам просто следует определить метод finalize() в Java. 
Среда выполнения Java производит вызов данного метода непосредственно перед обработкой объекта
данного класса.

В составе метода finalize(), вы указываете те действия, которые должны быть выполнены 
перед уничтожением объекта.

### В общем виде метод finalize() выглядит следующим образом:

```Java
protected void finalize() {
// здесь финализация кода
}
```

Здесь ключевое слово protected представляет спецификатор, 
предотвращающий доступ к finalize() посредством кода, определяемого вне его класса.

Это свидетельствует о том, что вы не можете знать как или даже 
когда будет производиться выполнение finalize(). 
К примеру, если ваша программа будет окончена до «сборки мусора», finalize() не будет выполняться.







