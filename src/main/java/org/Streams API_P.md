# Stream API

## Введение

У многих понятие `Stream` вызывает путаницу, из-за того, что _Stream_ переводится как _поток_, а в _Java_ есть множетсво аналогий, таких как потоки ввода-вывода,
многопоточная реализация (нити), потоки чтения файлов и т.п. 

_Stream API_ - это про потоковую обработку коллекций, как правило, `List`'ов. Поток - потому что каждый элемент проносится по всей конструкции как-будто поток.

_Stream API_ не предлагает решения для всех возможных сценариев обработки данных. Однако, большинство задач могут быть описаны следующим общим шаблоном:
1. Источник данных.
2. Выполнение преобразований.
3. Сохранение результата в новую структуру данных.

Если ваша задача не соответствует этому шаблону, то, возможно, использование Stream API не будет оптимальным решением

## Стримоз

В сети гуляет такой термин, как "Стримоз головного мозга", которым обозначается стремление разработчиков, недавно узнавших про эту технологию,
постоянно их использовать. Будьте разумны и применяйте `Stream` только тогда, когда для этого есть основание!

## Начало обработки

Чтобы воспользоваться _Stream API_ необходимо применить для коллекции метод `stream()`.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 0, 2000, 4333, -555, 2345, 55, 7896));
Stream<Integer> stream = list.stream();
```
Как видно из примера, существует специальный тип данных, олицетворяющий _Stream API_.

## Как обрабатывать?

После создания потока `Stream` применяются специальные методы для обработки - они называются **_конвейерные_** (промежуточные) методы. Из этих методов
будет выстраиваться целая цепочка последовательных операций.

Но конвейерными методами всё не ограничивается, так как любой `Stream` должен иметь какой-то логический финал. Это может быть вывод получившихся значений,
нахождение суммы или конвертация в коллекцию. Такой финальный метод будет называться **_терминальным_**.

**!ВАЖНО!**

Без терминального метода `Stream` не запустится!

## Конвейерные методы

Прежде чем приступить к разбору конвейерных методов стоит отметить, что все примеры для них, будут заканчиваться терминальным оператором `foreach`, который
будет выводить результат обработки

### filter(Predicate)

Метод `filter` принимает предикат в качестве параметра. Данный метод используется для фильтрации элементов стрима.

В примере ниже будут отсеяны все отрицательные числа.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 0, 2000, 4333, -555, 2345, 55, 7896));

list.stream()
        .filter(x -> x > 0)
        .forEach(System.out::println);
```

### map(Function)

Метод `map` принимает функциональный интерфейс `Function`. Метод `map` предназначен для обработки данных и их преобразования.
После себя он отправляет по потоку уже обработанные (изменённые) данные.

В примере ниже каждый элемент коллекции делит на 10.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 0, 2000, 4333, -555, 2345, 55, 7896));

list.stream()
        .map(integer -> integer /= 10)
        .forEach(System.out::println);
```

В примере ниже каждое число преобразуется в строку

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 0, 2000, 4333, -555, 2345, 55, 7896));

list.stream()
        .map(integer -> integer + " рублей")
        .forEach(System.out::println);
```

### flatMap()

Метод `flatMap()` позволяет создать один поток из множества потоков. В качестве параметра принимает функцию, которая применяется к каждому элементу потока.

Рассмотрим пример, в котором двумерный список становится одномерным.
```java
List<List<Integer>> lists = new ArrayList<>();
lists.add(new ArrayList<>(List.of(10, 20, 30)));
lists.add(new ArrayList<>(List.of(40, 50, 60)));

lists.stream()
        .flatMap(Collection::stream)
        .forEach(System.out::println);
```

В примере ниже рассмотрим ситуацию, когда из двумерного массива списков нужно оставить только чётные элементы

```java
List<List<Integer>> lists = new ArrayList<>();
lists.add(new ArrayList<>(List.of(10, 23, 30)));
lists.add(new ArrayList<>(List.of(40, 11, 60)));

lists.stream()
        .flatMap(Collection::stream)
        .filter(x -> x % 2 == 0)
        .forEach(System.out::println);
```

### distinct()

Метод `distinct` оставляет только уникальные элементы.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 0, 2000, 0, -555, 10, 10, 7));

list.stream()
        .distinct()
        .forEach(System.out::println);
```

### limit(int)

Метод `limit` позволяет ограничить поток данных в соответствии с указанным целочисленным параметром. Говоря проще, метод 
`limit` "обрубает" список.

В примере ниже показано как ограничить потоковую обработку первыми пятью элементами.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 17, 2000, 0, -555, 10, 10, 7));

list.stream()
        .limit(5)
        .forEach(System.out::println);
```

### skip(int)

Метод `skip` позволяет пропустить определённое количестве элементов в стриме. Указывая целое число как параметр мы определяем
количество элементов, которое будет пропущено

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 17, 2000, 0, -555, 10, 10, 7));

list.stream()
        .skip(5)
        .forEach(System.out::println);
```

### sorted()

Метод `sorted` позволяет отсортировать данные. Метод `sorted` взаимодействует с `Comparable` объектами, поэтому со стандартными типами данных проблем не возникает.
Строки сортируются по алфавиту, числа - по возрастанию. Если это будут кастомные объекты, тогда для них необходимо будет определить интерфейс `Comparable`.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 17, 2000, 0, -555, 10, 10, 7));

list.stream()
        .sorted()
        .forEach(System.out::println);
```

### takeWhile(Predicate)

Метод `takeWhile` оздает новый поток, содержащий элементы исходного потока до тех пор, пока они удовлетворяют указанному условию. Если 
первый элемент потока не соответствует предикату, новый поток будет пустым.

Для примера ниже выведутся числа 10, 17 и 2000, так как -20 уже не подходит под условие, а значит, `takeWhile` останавливает свою работу.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 17, 2000, -20, -555, 10, 10, 7));

list.stream()
        .takeWhile(integer -> integer > 0)
        .forEach(System.out::println);
```

### dropWhile(Predicate)

Метод `dropWhile` возвращает новый поток, который включает все элементы исходного потока, начиная с первого элемента, не удовлетворяющего 
указанному условию. В момент, когда предикат возвращает false, все последующие элементы из исходного потока включаются в новый поток.
По большому счёту, метод `dropWhile` противоположен `takeWhile`

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 17, 2000, 0, -555, 10, 10, 7));

list.stream()
        .dropWhile(integer -> integer > 0)
        .forEach(System.out::println);
```

### peek(Consumer)

Метод `peek()` выполняют операцию к каждому элементу. 

Метод `peek()` удобен, когда необходимо выполнить дополнительные операции с элементами потока, например, для целей логирования,
отладки или профилирования, не меняя при этом сами элементы. 

В общем случае, рекомендуется использовать `peek()` редко и, преимущественно, для отладки, а не как средство модификации элементов потока.
Если требуется изменить элементы потока, предпочтительнее использовать метод `map()`.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

numbers.stream()
       .peek(System.out::println)
       .forEach(System.out::println);
```

## Терминальные операторы

### сollect(Collector)

Метод `collect` часто используется в конвейере потока. Его применяют для сбора результата потока в определенную структуру: строку, коллекцию (`List`, `Set`, `Map`).

Метод принимает объект типа `Collector` в качестве аргумента, который определяет способ осуществления операции подсчета.

В примере ниже элементы исходного списка фильтруются (остаются только положительные), затем каждый элемент делится на 10, а после этого всё что осталось собирается в 
новый `List`.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 17, 2000, 0, -555, 10, 10, 7));

List<Integer> result = list.stream()
        .filter(num -> num > 0)
        .map(num -> num / 10)
        .collect(Collectors.toList());

System.out.println(result);
```

Аналогично предыдущему варианту, но здесь всё собирается в `Set`.
```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 17, 2000, 0, -555, 10, 10, 7));

        Set<Integer> result = list.stream()
                .filter(num -> num > 0)
                .map(num -> num / 10)
                .collect(Collectors.toSet());

        System.out.println(result);
```

### reduce()

Метод `reduce` применяется для комбинирования элементов потока в одно значение. Он отличается от метода `collect` тем, что использует 
ассоциативную функцию, принимающую два значения и объединяющую их в одно. Например, метод `reduce` можно использовать для суммирования 
чисел или для нахождения максимального или минимального числа.

Метод `reduce` возвращает `Optional` - специальный тип-обёртка. Необходим для безопасной обработки данных, так как в случае _Exception_
программа не падает.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 20, 30, 40, 50));

Optional<Integer> sumOpt = list.stream()
        .reduce((a, b) -> a + b);

int sum = sumOpt.get();
System.out.println(sum);
```

По-другому это можно было бы записать с использованием ссылки на метод

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 20, 30, 40, 50));

Optional<Integer> sumOpt = list.stream()
        .reduce(Integer::sum);

int sum = sumOpt.get();
System.out.println(sum);
```

### findFirst()

Метод `findFirst` возвращает `Optional` и служит для извлечения первого элемента из потока. Он обычно используется в сочетании с методом `filter`.

```java
ArrayList<Integer> list = new ArrayList<>(List.of(10, 20, 30, 40, 50));

Optional<Integer> sumOpt = list.stream()
        .filter(x -> x % 4 == 0)
        .findFirst();

int number = sumOpt.get();
System.out.println(number);
```

### anyMatch(Predicate)

Метод `anyMatch` используется для проверки, соответствует ли хотя бы один элемент потока указанному предикату.

```java
ArrayList<String> list = new ArrayList<>(List.of("Прости", "Прощай", "Привет"));

boolean isContains = list.stream().anyMatch(string -> string.equalsIgnoreCase("привет"));
System.out.println(isContains);
```

### allMatch(Predicate)

Метод `allMatch` похож на метод `anyMatch`, но, в отличие от него, метод `allMatch` вернёт `true` только в том случае,
если все элементы соответствуют указанному предикату.